package com.ohgiraffers.chap08.section01.extend;

public class Application {
    public static void main(String[] args) {

        /* 수업목표. 상속에 대해 이해할 수 있다. */
        /*
        * 상속(inheritance)은 현실 세계의 상속과 비슷한 개념
        * 부모가 가지고 있는 재산(자바에서는 클래스가 가지는 멤버)을 자식이 물려받는 의미
        * 클래스 또한 부모클래스와 자식클래스로 역할을 나누어서 부모가 가지는 멤버를 자식이 물려받아
        * 자기의 멤버인 것처럼 사용할 수 있도록 만든 기술임
        *
        * 하지만 단순히 물려받는 개념보다 조금 더 나아가
        * 자바에서의 상속은 부모클래스의 확장(extend)의 개념을 가짐
        * 물려받아서 자신의 것처럼 사용하는 것 뿐만 아니라 추가적인 멤버도 작성이 가능해짐
        * 특히 메소드 재정의(overriding)라는 기술을 이용해 부모가 가진 메소드를 재정의하는 것도 가능
        *
        * 메소드 재정의(overriding)란 부모가 가지는 메소드 선언부를 그대로 사용하면서
        * 자식클래스가 정의한 메소드대로 동작하도록 구현 몸체 부분을 새롭게 다시 작성하는 기술
        * 메소드 재정의를 하면 메소드를 호출할 시 재정의한 메소드가 우선적으로 동작하게 됨
        *
        * 이러한 상속이라는 기술을 사용하게 되면 얻게되는 이점은 크게 두 가지로 볼 수 있음
        * 1. 새로운 클래스 작성 시 기존에 작성한 클래스를 재사용할 수 있음
        *   1-1. 재사용 시 생산성을 크게 향상시킬 수 있음(새롭게 작성하는 것보다 빠름)
        *   1-2. 공통적으로 사용하는 코드가 부모 클래스에 존재하면 수정사항이 생길 시 부모 클래스만 수정해도
        *        전체적으로 적용됨(유지보수성 증가)
        *   2. 클래스 간 계층 관계가 형성되며 다형성의 문법적인 토대가 됨
        *
        * 하지만 상속으로 인한 단점도 존재함
        * 1. 부모클래스의 기능을 추가/변경할 시 자식클래스가 정상적으로 동작하는지에 대한 예측이 힘듦
        *    상속 구조가 복잡해질수록 그 영향에 대한 예측이 힘들며 이런 단점이
        *    유지보수성이 증가한다는 장점과 반대로 유지보수성에 악영향을 끼침
        * 2. 또한 부모클래스의 변경 또한 쉽지 않음
        *    자식클래스에서 중요하게 사용하는 기능인 경우
        *    부모클래스를 변경할 시 자식 클래스에 모두 영향을 줄 수 있음
        * 3. 부모클래스에서는 의미있었던 기능이 자식클래스에서는 무의미할 수 있음(불필요한 기능이 추가됨)
        *
        * 장점과 단점을 고려했을 때
        * 상속은 재사용이라는 장점만 보게 되면 오용의 가능성이 있기 때문에 유지보수에 좋지 않은 코드를 작성할 확률이 높음
        * 상속은 IS-A 관계로 구분되는 경우에만 사용해야 함
        *
        * 객체지향 설계 관점에서 바라보는 상속
        * 모든 객체는 자신이 수신한 메세지에 대해 응답을 해야하는 책임을 가지며, 그 책임의 규모는 적절해야 함
        * 적절한 책임을 가진 객체들이 서로 협력(메세지 수신과 응답)을 통해 프로그램이 동작하는 것이
        * 객체지향 프로그램임
        *
        * 적절한 책임을 수행하는 객체 또한 그 객체만 수행할 수 있는 기능이라기 보다 역할의 관점으로 바라봐야 함
        * 역할이란 동일한 동작을 수행하는 것을 정의한 것이며, 대체 가능성을 의미함
        * 부모클래스를 추상화하는 경우에는 역할의 관점으로 바라봐야 함
        * 그래야 자식클래스로 생성한 객체들이 서로 역할을 수행해가며 유연한 코드를 작성할 수 있게 됨
        * 동일한 역할을 가지는 모든 객체는 동일한 메세지를 수신하기는 하지만
        * 객체 별로 그 메세지에 응답하는 방식은 서로 다를 수 있음(다형성)
        * */

        /*
        * Car라는 클래스를 하나 만들 것
        * 자동차의 역할을 수행할 수 있는 객체
        * 하지만 기본적인 기능만 수행할 수 있음
        * */

        /* 1. Car 인스턴스 생성 후 메소드 호출 */
        Car car = new Car();

        car.soundHorn();
        car.run();
        car.soundHorn();
        car.stop();
        car.soundHorn();

        /*
        * 정상적으로 동작함
        * 하지만 자동차라고 하기에는 아직 기능들이 초라함
        * 상속을 예시로 활용하기 위해 몇 가지 목적을 가진 자동차들을 조금 더 추가할 예정
        * FireCar, RacingCar를 추가할 것
        *
        * 소방차, 레이싱카 모두 자동차임
        * 하지만 모든 자동차는 소방차 혹은 스쿨버스 혹은 레이싱카가 아님
        * FireCar is a Car (o) / Car is a FireCar (x)
        * RacingCar is a Car (o) / RacingCar is a Car(o)
        *
        * 이러한 관계가 성립되는 것을 IS-A 관계라고 함
        * */

        /* 2. FireCar 인스턴스 생성 후 Car 클래스에 작성한 메소드를 사용할 수 있는지 확인 */
        FireCar fireCar = new FireCar();

        fireCar.soundHorn();
        fireCar.run();
        fireCar.soundHorn();
        fireCar.stop();
        fireCar.soundHorn();

        /*
        * FireCar 클래스에는 아무 것도 작성하지 않았는데 Car 클래스가 가진 메소드를 전부 사용할 수 있음
        * 하지만 private 멤버는 접근이 불가능
        * */
        //fireCar.runningStatus();      //private 속성 접근 불가
        //fireCar.isRunning();            //private 메소드 접근 불가     //protected 변경 후 사용 가능

        /*
        * 근데 소방차의 경적 소리가 너무 일반적
        * 조금 더 다급한 경적소리가 울리도록 메소드를 작성하고 싶다면?
        * FireCar 클래스를 수정해보자
        * */

        /* 3. 상속은 확장. 추가적인 기능도 작성할 수 있음 */
        fireCar.sprayWater();

        /* 4. RacingCar 인스턴스 생성 후 메소드 호출해서 테스트 */
        RacingCar racingCar = new RacingCar();

        racingCar.soundHorn();
        racingCar.run();
        racingCar.soundHorn();
        racingCar.stop();
        racingCar.soundHorn();

        /*
        * 레이싱카에 경적 소리를 내는 것이 적합하지 않슴
        * 하지만 Car를 상속받았기 때문에 어쩔 수 없이 RacingCar도 경기장에서 경적을 울리게 됨
        * 상속으로 인해 불필요한 기능이 추가될 수 있다는 점이 이런 부분임
        * */

        /*
        * 여기까지 작성하고 실행해서 레이싱카의 기능들이 잘 동작하는지 확인해보자
        * 상속만 했을 뿐이지 거의 새로운 클래스를 작성한 것과 다름이 없음
        *
        * 불필요하게 상속을 하는 경우 오히려 유지보수성에 악영향을 미침
        * extends Car 부분을 제거해보면 수많은 컴파일 에러가 발생하는 것을 볼 수 있을 것
        * 이런 경우는 차라리 상속을 하지 않는 것이 더 나은 상황이 됨
        *
        * 그래서 객체지향프로그래밍에서 상속은 다형성의 토대가 되는 중요한 기술이긴 하지만
        * 오용할 경우 이러한 유지보수에 악영향을 미칠 수 있다는 의미이기도 함
        *
        * 상속보다는 작게 작성한 블럭을 조합하며 프로그래밍 하는 것이 더 좋은 방식이 됨
        * 하지만 이 부분은 초급 개발자가 공부할 수 있는 영역을 벗어나기에 후에 깊게 공부해야 이해할 수 있을 것
        * */
    }
}
